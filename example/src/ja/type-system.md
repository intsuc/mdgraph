# 型システム

## 型システムとは？

**型システム**とは、式、変数、関数、そしてプログラム構成要素に *型* を割り当てる規則の集合です。
主な目的は次のとおりです:

- エラー検出（例: 数値と文字列を加算する）
- 意図の文書化（例: 「この関数は null を返さない」）
- 最適化の支援（例: 実行時チェックの回避）

形式的には、型システムは次のような *型付け判断（typing judgment）* を定義します:

> Γ ⊢ e : T

意味: 仮定 Γ（コンテキスト）のもとで、式 `e` は型 `T` を持つ。

---

## 静的型付け vs 動的型付け

### 静的型付け

型は **コンパイル時** にチェックされます。

- 例: Haskell, Rust, Java, TypeScript（コンパイルを伴う場合）
- 長所:
  - 多くのエラーを実行前に検出できる
  - ツール支援が強い（リファクタリング、補完）
  - しばしば高い性能
- 短所:
  - （推論が強力でない限り）事前の注釈が増える
  - 正当なプログラムでも拒否されることがある

### 動的型付け

型は **実行時** にチェックされます。

- 例: Python, JavaScript, Ruby
- 長所:
  - 儀式的な記述が少なく、注釈も少ない
  - 柔軟なメタプログラミングがしやすい
- 短所:
  - 該当するコードパスが実行されるまでエラーが表面化しない
  - 安全な最適化やリファクタリングが難しい

多くの言語は両者を混ぜています（例: TypeScript の段階的型付け、型ヒント付き Python）。

---

## 強い型付け vs 弱い型付け

厳密な定義は文脈で変わりますが、非公式には次のように言われます:

- **強い型付け**: 明示的な変換なしに、型同士で意味のない操作ができないようにする
  - 例: 文字列と整数を足すには、どちらかを変換しないといけない
- **弱い型付け**: 値が暗黙に別の型へ強制変換（coerce）される
  - 例: `"1" + 2` が言語によって `"12"` や `3` になる

「強い/弱い」は「静的/動的」ほど精密ではなく、しばしば口語的に使われます。

---

## 型健全性（soundness）と安全性

型システムが **健全（sound）** であるとは:

> 「型付けできるプログラムは壊れない（Well-typed programs do not go wrong.）」

より形式的には:

- **進行（Progress）**: 型付けされたプログラムは、値であるか、評価の1ステップを進められる
- **保存（Preservation）**: 型付けされたプログラムが1ステップ進むなら、その結果も型付けされる

健全な型システムは、特定の実行時エラー（例: 「関数でないものを呼び出す」）が、型付けできるプログラムでは起きないことを保証します。

一方で、利便性のために健全性を一部犠牲にする体系もあります（例: TypeScript の `any`、システム言語の生ポインタ、`unsafe` ブロック）。

---

## 名前的型付け（nominal） vs 構造的型付け（structural）

### 名前的型付け（Nominal typing）

型は **同じ名前** を持つか、明示的に関係が宣言されている場合に互換になります。

- 例: Java のクラス、Rust の構造体
- 長所:
  - API と境界が明確で、意図がはっきりする
- 短所:
  - 似た型を互換にするためのボイラープレートが増える

### 構造的型付け（Structural typing）

型は **形（shape）が一致** すれば互換になります。

- 例: TypeScript の interface、Go の interface（暗黙）
- 長所:
  - 非常に柔軟で、合成やリファクタリングがしやすい
- 短所:
  - 偶然の互換（たまたま一致してしまう）
  - エラーメッセージが複雑になりやすい

---

## 部分型（subtyping）と多相（polymorphism）

型システムはしばしば **部分型** をサポートします:

- `S` が `T` の部分型なら（`S <: T`）、`S` 型の値は `T` が期待される場所で使える
- 例: `Circle <: Shape`

部分型は **多相** と相互作用します:

- **パラメトリック多相**（ジェネリクス）: 関数やデータ構造が型を抽象化する
  - 例: `List<T>`、`fn id<T>(x: T) -> T`
- **アドホック多相**（オーバーロード、型クラス）: 型によって振る舞いが変わる

分散（variance: 共変・反変・不変）は、型コンストラクタが部分型に対してどう振る舞うかを表します。例えば `List<Circle>` を `List<Shape>` が必要な場所で使えるかどうか、などです。

---

## 型推論

**型推論**は、主に局所的な使用状況から型を自動的に推定します。

- 多くの注釈を省略しつつ静的型付けを維持できる
- 例: ML/Haskell の Hindley–Milner 推論、Rust の局所推論

トレードオフ:

- 強力な推論ほど、エラーメッセージが理解しづらくなることがある
- 一部の体系は、決定可能性と高速性のために推論を制限する（例: 高階ランク推論をしない）

---

## まとめ

型システムは:

- 形式的な規則により、プログラム構成要素に型を割り当てる
- 静的/動的、強い/弱い、名前的/構造的といった性質を持ちうる
- ある種の実行時エラーが起こらないことについて健全性保証を提供しうる
- しばしば部分型、多相、推論をサポートし、より安全で表現力の高いプログラミングを可能にする

安全性、性能、表現力、使い勝手のバランスを取るために、言語ごとに異なる設計選択がなされます。
